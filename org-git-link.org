* STARTED Create git link type                                      :PROJECT:
   :LOGBOOK:
   CLOCK: [2009-10-01 Thu 17:20]--[2009-10-01 Thu 18:05] =>  0:45
   - Note taken on [2009-09-24 Thu 18:09] \\
     We also need to specify a method how to access the file: Either
     read-only via git show/cat-file or via git checkout (but this
     changes the working directory). Maybe have a method field like in
     tramp as well.
   - Note taken on [2009-09-24 Thu 18:07] \\
     We need to find a way to specify the Git dir, especially if the
     tracked directory has subdirectories.
   :END:
   
   Newsgroup entry which gave the idea:
  [[gnus:nntp%2Bnews.gmane.org:gmane.emacs.orgmode#200907241232.52729.torsten.wagner@googlemail.com][Email from Torsten Wagner: org-mode meets git a first pro]]

  Sometimes I need exactly that: A link to a file in a specific
  branch and at a specific version of a git repository. At the
  moment I am doing this by hand, e.g. in my xxx project
  file:
#+begin_EXAMPLE 
    Unser Anteil dazu im git Branch xxxantwort:
    [[file:~/misc/xxx-antrag/xxx-antrag.tex]]
#+end_EXAMPLE 
    Ideally we could simply create a link type which would then
    either =git-show= or =git-checkout= (or even =git-cat-file=)
    the specific file. =git-checkout= changes the working
    directory, which ist probably not what we want (you can
    always use =magit= or =vc-git= for that. Therefore,
    =git-show= is probably the best choice (see also the git FAQ
    entry). In the link need to specify
    - the git directory,
      [Aside: We need to handle bare repositories as well as
      normal working directories. If we specify the working
      directory, we need to actually pass the .git subdirectory
      to the git command. ]
    - the commit of the specific file version (HEAD by default),
    - the path to the file from GIT_DIR.

    The link format would presumably look something like
    [[git:$GIT_DIR:<$COMMIT>:$FILE]]. Following the link would then show a
    temporary buffer with the output of 
    : git --no-pager --git-dir=$GIT_DIR</.git> show $COMMIT:$FILE
* References
** Specifying objects
    :PROPERTIES:
    :ID:       83573d86-8df3-4f56-9927-a917e4b62509
    :END:
    From the man page of git-rev-parse:
#+begin_EXAMPLE 
SPECIFYING REVISIONS
       A revision parameter typically, but not necessarily, names a commit
       object. They use what is called an extended SHA1 syntax. Here are
       various ways to spell object names. The ones listed near the end of
       this list are to name trees and blobs contained in a commit.

       ·   The full SHA1 object name (40-byte hexadecimal string), or a
           substring of such that is unique within the repository. E.g.
           dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the
           same commit object if there are no other object in your repository
           whose object name starts with dae86e.

       ·   An output from git-describe; i.e. a closest tag, optionally
           followed by a dash and a number of commits, followed by a dash, a
           g, and an abbreviated object name.

       ·   A symbolic ref name. E.g. master typically means the commit object
           referenced by $GIT_DIR/refs/heads/master. If you happen to have
           both heads/master and tags/master, you can explicitly say
           heads/master to tell git which one you mean. When ambiguous, a
           <name> is disambiguated by taking the first match in the following
           rules:

            1.  if $GIT_DIR/<name> exists, that is what you mean (this is
               usually useful only for HEAD, FETCH_HEAD, ORIG_HEAD and
               MERGE_HEAD);

            2.  otherwise, $GIT_DIR/refs/<name> if exists;

            3.  otherwise, $GIT_DIR/refs/tags/<name> if exists;

            4.  otherwise, $GIT_DIR/refs/heads/<name> if exists;

            5.  otherwise, $GIT_DIR/refs/remotes/<name> if exists;

            6.  otherwise, $GIT_DIR/refs/remotes/<name>/HEAD if exists.

               HEAD names the commit your changes in the working tree is based
               on. FETCH_HEAD records the branch you fetched from a remote
               repository with your last git-fetch invocation. ORIG_HEAD is
               created by commands that moves your HEAD in a drastic way, to
               record the position of the HEAD before their operation, so that
               you can change the tip of the branch back to the state before
               you ran them easily. MERGE_HEAD records the commit(s) you are
               merging into your branch when you run git-merge.

       ·   A ref followed by the suffix @ with a date specification enclosed
           in a brace pair (e.g. {yesterday}, {1 month 2 weeks 3 days 1 hour 1
           second ago} or {1979-02-26 18:30:00}) to specify the value of the
           ref at a prior point in time. This suffix may only be used
           immediately following a ref name and the ref must have an existing
           log ($GIT_DIR/logs/<ref>). Note that this looks up the state of
           your local ref at a given time; e.g., what was in your local master
           branch last week. If you want to look at commits made during
           certain times, see --since and --until.

       ·   A ref followed by the suffix @ with an ordinal specification
           enclosed in a brace pair (e.g. {1}, {15}) to specify the n-th prior
           value of that ref. For example master@{1} is the immediate prior
           value of master while master@{5} is the 5th prior value of master.
           This suffix may only be used immediately following a ref name and
           the ref must have an existing log ($GIT_DIR/logs/<ref>).

       ·   You can use the @ construct with an empty ref part to get at a
           reflog of the current branch. For example, if you are on the branch
           blabla, then @{1} means the same as blabla@{1}.

       ·   A suffix ^ to a revision parameter means the first parent of that
           commit object. ^<n> means the <n>th parent (i.e. rev^ is equivalent
           to rev^1). As a special rule, rev^0 means the commit itself and is
           used when rev is the object name of a tag object that refers to a
           commit object.

       ·   A suffix ~<n> to a revision parameter means the commit object that
           is the <n>th generation grand-parent of the named commit object,
           following only the first parent. I.e. rev~3 is equivalent to rev^^^
           which is equivalent to rev^1^1^1. See below for a illustration of
           the usage of this form.

       ·   A suffix ^ followed by an object type name enclosed in brace pair
           (e.g. v0.99.8^{commit}) means the object could be a tag, and
           dereference the tag recursively until an object of that type is
           found or the object cannot be dereferenced anymore (in which case,
           barf). rev^0 introduced earlier is a short-hand for rev^{commit}.

       ·   A suffix ^ followed by an empty brace pair (e.g. v0.99.8^{}) means
           the object could be a tag, and dereference the tag recursively
           until a non-tag object is found.

       ·   A colon, followed by a slash, followed by a text: this names a
           commit whose commit message starts with the specified text. This
           name returns the youngest matching commit which is reachable from
           any ref. If the commit message starts with a !, you have to repeat
           that; the special sequence :/!, followed by something else than !
           is reserved for now.

       ·   A suffix : followed by a path; this names the blob or tree at the
           given path in the tree-ish object named by the part before the
           colon.

       ·   A colon, optionally followed by a stage number (0 to 3) and a
           colon, followed by a path; this names a blob object in the index at
           the given path. Missing stage number (and the colon that follows
           it) names a stage 0 entry. During a merge, stage 1 is the common
           ancestor, stage 2 is the target branch´s version (typically the
           current branch), and stage 3 is the version from the branch being
           merged.
       Here is an illustration, by Jon Loeliger. Both commit nodes B and C are
       parents of commit node A. Parent commits are ordered left-to-right.

           G   H   I   J
            \ /     \ /
             D   E   F
              \  |  / \
               \ | /   |
                \|/    |
                 B     C
                  \   /
                   \ /
                    A

           A =      = A^0
           B = A^   = A^1     = A~1
           C = A^2  = A^2
           D = A^^  = A^1^1   = A~2
           E = B^2  = A^^2
           F = B^3  = A^^3
           G = A^^^ = A^1^1^1 = A~3
           H = D^2  = B^^2    = A^^^2  = A~2^2
           I = F^   = B^3^    = A^^3^
           J = F^2  = B^3^2   = A^^3^2
#+end_EXAMPLE
** Viewing a specific version of a file in git:
    From the [[http://git.or.cz/gitwiki/GitFaq#Howtoviewanoldrevisionofafileordirectory.3F][Git FAQ]]:
#+begin_EXAMPLE 
How to view an old revision of a file or directory?

Use command "git show" with a colon and filename:

git show <commit>:path/file

The <commit> can be commit id, branch name, tag, relative pointer
like HEAD~2 etc. If you don't give any path or file (i.e. just
<commit>:), git will display the file listing of repository's
root directory. Examples:

git show v1.4.3:git.c
git show f5f75c652b9c2347522159a87297820103e593e4:git.c
git show HEAD~2:git.c
git show master~4:
git show master~4:doc/
git show master~4:doc/ChangeLog
#+end_EXAMPLE
* Tasks:
** DONE Check out man pages of git-rev-parse 
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-07-24 Fri 17:08]
   CLOCK: [2009-07-24 Fri 16:55]--[2009-07-24 Fri 17:08] =>  0:13
   :END:
   Find out the possibilities to specify a file in a specific
   branch and version. See [[id:83573d86-8df3-4f56-9927-a917e4b62509][Specifying objects]].
** DONE Check whether attachments care about commits
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-07-24 Fri 15:56]
   CLOCK: [2009-07-24 Fri 15:54]--[2009-07-24 Fri 15:56] =>  0:02
   :END:
   No they don't. (Only creating their own commits). No help
   from there.
** DONE Find out how to create new link types 
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-07-24 Fri 15:54]
   CLOCK: [2009-07-24 Fri 15:46]--[2009-07-24 Fri 15:54] =>  0:08
   :END:
   See [[info:org:Adding%20hyperlink%20types][info:org:Adding hyperlink types]]
** DONE Find a way to get the specific xxx file mentioned above
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-07-24 Fri 15:45]
   CLOCK: [2009-07-24 Fri 15:30]--[2009-07-24 Fri 15:45] =>  0:15
   :END:
   =git show xxxantwort:xxx-antrag.tex= does the trick.
** STARTED find out how to fill buffer with result of shell process  :ATTACH:
   :LOGBOOK:
   CLOCK: [2009-10-01 Thu 16:30]--[2009-10-01 Thu 17:07] =>  0:37
   CLOCK: [2009-07-24 Fri 16:24]--[2009-07-24 Fri 17:03] =>  0:39
   CLOCK: [2009-07-24 Fri 15:58]--[2009-07-24 Fri 16:20] =>  0:22
   :END:
   :PROPERTIES:
   :Attachments: simple.el man.el org-git.el
   :ID:       19e759de-ea08-4848-9799-1303a5cc078f
   :END:
   Looking at simple.el (shell-command-on-region) and man.el
   (man) to find out how to call shell processes. Synchronous
   calling ist simpler. shell-command should simply work,
   though.
** TODO find out how to create a new link type in org-mode
** TODO write test file in org-mode
