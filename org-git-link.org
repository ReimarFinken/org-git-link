* STARTED Create git link type                                      :PROJECT:
   :LOGBOOK:
   CLOCK: [2009-10-01 Thu 17:20]--[2009-10-01 Thu 18:05] =>  0:45
   - Note taken on [2009-09-24 Thu 18:09] \\
     We also need to specify a method how to access the file: Either
     read-only via git show/cat-file or via git checkout (but this
     changes the working directory). Maybe have a method field like in
     tramp as well.
   - Note taken on [2009-09-24 Thu 18:07] \\
     We need to find a way to specify the Git dir, especially if the
     tracked directory has subdirectories.
   :END:
   
   Newsgroup entry which gave the idea:
  [[gnus:nntp%2Bnews.gmane.org:gmane.emacs.orgmode#200907241232.52729.torsten.wagner@googlemail.com][Email from Torsten Wagner: org-mode meets git a first pro]]

  Sometimes I need exactly that: A link to a file in a specific
  branch and at a specific version of a git repository. At the
  moment I am doing this by hand, e.g. in my xxx project
  file:
#+begin_EXAMPLE 
    Unser Anteil dazu im git Branch xxxantwort:
    [[file:~/misc/xxx-antrag/xxx-antrag.tex]]
#+end_EXAMPLE 
    Ideally we could simply create a link type which would then
    either =git-show= or =git-checkout= (or even =git-cat-file=)
    the specific file. =git-checkout= changes the working
    directory, which ist probably not what we want (you can
    always use =magit= or =vc-git= for that). Therefore,
    =git-show= is probably the best choice (see also the git FAQ
    entry). In the link need to specify
    - the git directory,
      [Aside: We need to handle bare repositories as well as
      normal working directories. If we specify the working
      directory, we need to actually pass the .git subdirectory
      to the git command. ]
    - the commit of the specific file version (HEAD by default),
    - the path to the file from GIT_DIR.

    
    One problem with this is that the commit can also contain one
    or more colons. Therefore the commit part should be the last
    part of the link. Another issue is to be as user friendly as
    possible for the default usage, which is saying: I want
    version such and such (or a particular branch) of this file.
    I therefore propose the following syntax:

* Proposed Git link syntax
  - Bare git form :: [[git:$GIT_DIR::$OBJECT]]
    Example:
    #+begin_EXAMPLE 
    [[gitbare:~/misc/xxx-antrag/.git::xxxantwort:xxx-antrag.tex]]
    #+end_EXAMPLE
    This is the more bare metal version and directly translates
    to
    : git --no-pager --git-dir=$GIT_DIR show $OBJECT
    Using this version one can also view files from a bare git
    repository.

  - User friendy form :: [[git:$PATH_TO_FILE::$COMMIT]]
    Example:
    #+begin_EXAMPLE 
    [[git:~/misc/xxx-antrag/xxx-antrag.tex::xxxantwort]]
    #+end_EXAMPLE
    This is restricted to files in a working directory and ignores
    bare repositories on purpose (see the bare form for that). From
    the (not necessarily existing) file path we must first
    extract the GIT_DIR. This is done in the following way:
    Starting with the directory of our current file, we check
    whether
 
    - the directory exists and
    - whether a .git subdirectory exists.

    If not, we try the same with the parent directory. The
    $PATH_TO_FILE (which can be given as a local link) is thus
    separated into a GIT_DIR part and a FILE part without a
    preceding slash. Git is now called as
    : git --no-pager --git-dir=$GIT_DIR/.git show $COMMIT:$FILE
    Colons in the remaining COMMIT string (to specify files in
    the index or commits starting with a certain string) are
    processed as is.
* References
** Testing whether git directory is valid
   Valid git directory can be tested with git-rev-parse
   --git-dir=...
   other scripts simply test for the existence of .git / the name
   ending in .git
** Structure of the test git directory
   =testgitrepos= is a normal subdirectory of the source
   directory under git control. The following states have been
   tagged:

   - firstlevelfiles :: a.txt, b.txt, c.txt with contents a, b, c
        in testgitrepos directory

   - foobarbaztxt :: add foo/bar/baz.txt with contents baz

   - deletebaztxt :: removed foo/bar/baz.txt
** Creating a Link type in org mode
   See [[info:org:Adding%20hyperlink%20types][info:org:Adding hyperlink types]] and
#+begin_EXAMPLE 
org-add-link-type is a compiled Lisp function in `org.el'.

(org-add-link-type type &optional follow export)

Add type to the list of `org-link-types'.
Re-compute all regular expressions depending on `org-link-types'

follow and export are two functions.

follow should take the link path as the single argument and do whatever
is necessary to follow the link, for example find a file or display
a mail message.

export should format the link path for export to one of the export formats.
It should be a function accepting three arguments:

  path    the path of the link, the text after the prefix (like "http:")
  desc    the description of the link, if any, nil if there was no description
  format  the export format, a symbol like `html' or `latex'.

The function may use the FORMAT information to return different values
depending on the format.  The return value will be put literally into
the exported file.
Org-mode has a built-in default for exporting links.  If you are happy with
this default, there is no need to define an export function for the link
type.  For a simple example of an export function, see `org-bbdb.el'.
#+end_EXAMPLE
** Specifying objects
    :PROPERTIES:
    :ID:       83573d86-8df3-4f56-9927-a917e4b62509
    :END:
    From the man page of git-rev-parse:
#+begin_EXAMPLE 
SPECIFYING REVISIONS
       A revision parameter typically, but not necessarily, names a commit
       object. They use what is called an extended SHA1 syntax. Here are
       various ways to spell object names. The ones listed near the end of
       this list are to name trees and blobs contained in a commit.

       ·   The full SHA1 object name (40-byte hexadecimal string), or a
           substring of such that is unique within the repository. E.g.
           dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the
           same commit object if there are no other object in your repository
           whose object name starts with dae86e.

       ·   An output from git-describe; i.e. a closest tag, optionally
           followed by a dash and a number of commits, followed by a dash, a
           g, and an abbreviated object name.

       ·   A symbolic ref name. E.g. master typically means the commit object
           referenced by $GIT_DIR/refs/heads/master. If you happen to have
           both heads/master and tags/master, you can explicitly say
           heads/master to tell git which one you mean. When ambiguous, a
           <name> is disambiguated by taking the first match in the following
           rules:

            1.  if $GIT_DIR/<name> exists, that is what you mean (this is
               usually useful only for HEAD, FETCH_HEAD, ORIG_HEAD and
               MERGE_HEAD);

            2.  otherwise, $GIT_DIR/refs/<name> if exists;

            3.  otherwise, $GIT_DIR/refs/tags/<name> if exists;

            4.  otherwise, $GIT_DIR/refs/heads/<name> if exists;

            5.  otherwise, $GIT_DIR/refs/remotes/<name> if exists;

            6.  otherwise, $GIT_DIR/refs/remotes/<name>/HEAD if exists.

               HEAD names the commit your changes in the working tree is based
               on. FETCH_HEAD records the branch you fetched from a remote
               repository with your last git-fetch invocation. ORIG_HEAD is
               created by commands that moves your HEAD in a drastic way, to
               record the position of the HEAD before their operation, so that
               you can change the tip of the branch back to the state before
               you ran them easily. MERGE_HEAD records the commit(s) you are
               merging into your branch when you run git-merge.

       ·   A ref followed by the suffix @ with a date specification enclosed
           in a brace pair (e.g. {yesterday}, {1 month 2 weeks 3 days 1 hour 1
           second ago} or {1979-02-26 18:30:00}) to specify the value of the
           ref at a prior point in time. This suffix may only be used
           immediately following a ref name and the ref must have an existing
           log ($GIT_DIR/logs/<ref>). Note that this looks up the state of
           your local ref at a given time; e.g., what was in your local master
           branch last week. If you want to look at commits made during
           certain times, see --since and --until.

       ·   A ref followed by the suffix @ with an ordinal specification
           enclosed in a brace pair (e.g. {1}, {15}) to specify the n-th prior
           value of that ref. For example master@{1} is the immediate prior
           value of master while master@{5} is the 5th prior value of master.
           This suffix may only be used immediately following a ref name and
           the ref must have an existing log ($GIT_DIR/logs/<ref>).

       ·   You can use the @ construct with an empty ref part to get at a
           reflog of the current branch. For example, if you are on the branch
           blabla, then @{1} means the same as blabla@{1}.

       ·   A suffix ^ to a revision parameter means the first parent of that
           commit object. ^<n> means the <n>th parent (i.e. rev^ is equivalent
           to rev^1). As a special rule, rev^0 means the commit itself and is
           used when rev is the object name of a tag object that refers to a
           commit object.

       ·   A suffix ~<n> to a revision parameter means the commit object that
           is the <n>th generation grand-parent of the named commit object,
           following only the first parent. I.e. rev~3 is equivalent to rev^^^
           which is equivalent to rev^1^1^1. See below for a illustration of
           the usage of this form.

       ·   A suffix ^ followed by an object type name enclosed in brace pair
           (e.g. v0.99.8^{commit}) means the object could be a tag, and
           dereference the tag recursively until an object of that type is
           found or the object cannot be dereferenced anymore (in which case,
           barf). rev^0 introduced earlier is a short-hand for rev^{commit}.

       ·   A suffix ^ followed by an empty brace pair (e.g. v0.99.8^{}) means
           the object could be a tag, and dereference the tag recursively
           until a non-tag object is found.

       ·   A colon, followed by a slash, followed by a text: this names a
           commit whose commit message starts with the specified text. This
           name returns the youngest matching commit which is reachable from
           any ref. If the commit message starts with a !, you have to repeat
           that; the special sequence :/!, followed by something else than !
           is reserved for now.

       ·   A suffix : followed by a path; this names the blob or tree at the
           given path in the tree-ish object named by the part before the
           colon.

       ·   A colon, optionally followed by a stage number (0 to 3) and a
           colon, followed by a path; this names a blob object in the index at
           the given path. Missing stage number (and the colon that follows
           it) names a stage 0 entry. During a merge, stage 1 is the common
           ancestor, stage 2 is the target branch´s version (typically the
           current branch), and stage 3 is the version from the branch being
           merged.
       Here is an illustration, by Jon Loeliger. Both commit nodes B and C are
       parents of commit node A. Parent commits are ordered left-to-right.

           G   H   I   J
            \ /     \ /
             D   E   F
              \  |  / \
               \ | /   |
                \|/    |
                 B     C
                  \   /
                   \ /
                    A

           A =      = A^0
           B = A^   = A^1     = A~1
           C = A^2  = A^2
           D = A^^  = A^1^1   = A~2
           E = B^2  = A^^2
           F = B^3  = A^^3
           G = A^^^ = A^1^1^1 = A~3
           H = D^2  = B^^2    = A^^^2  = A~2^2
           I = F^   = B^3^    = A^^3^
           J = F^2  = B^3^2   = A^^3^2
#+end_EXAMPLE
** Viewing a specific version of a file in git:
    From the [[http://git.or.cz/gitwiki/GitFaq#Howtoviewanoldrevisionofafileordirectory.3F][Git FAQ]]:
#+begin_EXAMPLE 
How to view an old revision of a file or directory?

Use command "git show" with a colon and filename:

git show <commit>:path/file

The <commit> can be commit id, branch name, tag, relative pointer
like HEAD~2 etc. If you don't give any path or file (i.e. just
<commit>:), git will display the file listing of repository's
root directory. Examples:

git show v1.4.3:git.c
git show f5f75c652b9c2347522159a87297820103e593e4:git.c
git show HEAD~2:git.c
git show master~4:
git show master~4:doc/
git show master~4:doc/ChangeLog
#+end_EXAMPLE
* Implementation
  - [[file:org-git-link.el][Source file]]
  - [[file:test/test-git-link.el][Test file]]
* Tasks:
** DONE Check out man pages of git-rev-parse 
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-07-24 Fri 17:08]
   CLOCK: [2009-07-24 Fri 16:55]--[2009-07-24 Fri 17:08] =>  0:13
   :END:
   Find out the possibilities to specify a file in a specific
   branch and version. See [[id:83573d86-8df3-4f56-9927-a917e4b62509][Specifying objects]].
** DONE Check whether attachments care about commits
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-07-24 Fri 15:56]
   CLOCK: [2009-07-24 Fri 15:54]--[2009-07-24 Fri 15:56] =>  0:02
   :END:
   No they don't. (Only creating their own commits). No help
   from there.
** DONE Find out how to create new link types 
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-07-24 Fri 15:54]
   CLOCK: [2009-07-24 Fri 15:46]--[2009-07-24 Fri 15:54] =>  0:08
   :END:
   See [[info:org:Adding%20hyperlink%20types][info:org:Adding hyperlink types]]
** DONE Find a way to get the specific xxx file mentioned above
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-07-24 Fri 15:45]
   CLOCK: [2009-07-24 Fri 15:30]--[2009-07-24 Fri 15:45] =>  0:15
   :END:
   =git show xxxantwort:xxx-antrag.tex= does the trick.
** DONE find out how to fill buffer with result of shell process     :ATTACH:
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-05 Mon 17:35]
   CLOCK: [2009-10-05 Mon 17:28]--[2009-10-05 Mon 17:35] =>  0:07
   CLOCK: [2009-10-01 Thu 16:30]--[2009-10-01 Thu 17:07] =>  0:37
   CLOCK: [2009-07-24 Fri 16:24]--[2009-07-24 Fri 17:03] =>  0:39
   CLOCK: [2009-07-24 Fri 15:58]--[2009-07-24 Fri 16:20] =>  0:22
   :END:
   :PROPERTIES:
   :Attachments: simple.el man.el org-git.el
   :ID:       19e759de-ea08-4848-9799-1303a5cc078f
   :END:
   Looking at simple.el (shell-command-on-region) and man.el
   (man) to find out how to call shell processes. Synchronous
   calling ist simpler. shell-command should simply work, though.
   I will simply use shell-command or call-process. Don't know
   whether we need a shell. Actually, I don't need to spawn a
   shell just to call git. Let's try =call-process=, see
   [[info:elisp:Synchronous%20Processes][info:elisp:Synchronous Processes]].

** DONE write test script executable from the shell
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-13 Tue 16:46]
   CLOCK: [2009-10-13 Tue 16:35]--[2009-10-13 Tue 16:46] =>  0:11
   :END:
   
** DONE Specify link syntax
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-07 Wed 14:40]
   - State "STARTED"    from "DONE"       [2009-10-07 Wed 14:24]
   CLOCK: [2009-10-07 Wed 14:24]--[2009-10-07 Wed 14:40] =>  0:16
   - State "DONE"       from "STARTED"    [2009-10-05 Mon 17:03]
   CLOCK: [2009-10-05 Mon 16:30]--[2009-10-05 Mon 17:03] =>  0:33
   :END:
** DONE find out how to create a new link type in org-mode
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2009-10-05 Mon 17:35]
   :END:
   :PROPERTIES:
   :ID:       be9f8577-3e78-49c6-925c-090adc403fc6
   :END:
** write test file in org-mode                                      :PROJECT:
   :LOGBOOK:
   - Note taken on [2009-10-06 Tue 18:07] \\
     First, we need to define the actual structure of the git link
     file and  test file
   :END:
*** DONE plan structure of git link and test file
    - Note taken on [2009-10-10 Sat 00:49] \\
      test is still failing because two subsequent links append to the buffer rather than delete first.
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-06 Tue 18:05]
   CLOCK: [2009-10-06 Tue 17:43]--[2009-10-06 Tue 18:04] =>  0:21
   CLOCK: [2009-10-05 Mon 17:51]--[2009-10-05 Mon 18:04] =>  0:13
   :END:
*** DONE implement bare git type
    :LOGBOOK:
    CLOCK: [2009-10-09 Fri 16:40]--[2009-10-09 Fri 17:46] =>  1:06
    CLOCK: [2009-10-09 Fri 15:35]--[2009-10-09 Fri 15:37] =>  0:02
    :END:
** DONE rewrite org-git-show link to use org-open-file
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-13 Tue 16:30]
   CLOCK: [2009-10-13 Tue 15:24]--[2009-10-13 Tue 16:30] =>  1:06
   - Note taken on [2009-10-12 Mon 16:59] \\
     branch savefile
   :END:
   This is so that external apps and internal image viewers are
   automatically called. We need a new specification for
   org-git-show and need to find a way to extract a filename from
   the commit (I think it is safe to restrict ourselves to file
   links). Unfortunately org-open-at-point does not return the
   buffer of the visited file (well it cannot, since it might be
   displayed in an external program). 
** DONE find way to extract filename from commit part
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-13 Tue 15:18]
   - State "STARTED"    from "DONE"       [2009-10-13 Tue 15:13]
   CLOCK: [2009-10-13 Tue 15:13]--[2009-10-13 Tue 15:18] =>  0:05
   - State "DONE"       from "STARTED"    [2009-10-12 Mon 17:50]
   CLOCK: [2009-10-12 Mon 17:32]--[2009-10-12 Mon 17:50] =>  0:18
   :END:
   - links to diffs (commits) might be useful too. Let's see how
     magit handles these. At the moment we focus on file names
   - symbolic ref names are probably of no use for permanent
     storage. We can ignore those (but can also use HEAD etc. as
     file names). They are part of the ref before the path anyway
   - [X] if the commit part is simply a sha1, we have no information.
         We can just take the sha as filename
   - [X] A special case of the above are commits specified by the
     beginning of the commit-message (e.g. of the form =git
     show :/Delete=). These are specified by a colon followed
     immediately by a slash. In this case we can use the search
     string as a filename.
   - [X] For our most important case (suffix colon followed by a
     path) we can simply extract the part after the colon and use 
     (file-name-nondirectory "lewis/foo") on that
   - [X] For a link to an index file in a merge (not very useful),
     taking the file name of the part after the last colon should
     again also work
** DONE write test git directory
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-06 Tue 17:41]
   CLOCK: [2009-10-06 Tue 17:22]
   :END:
** DONE rewriting history for private email address
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-09 Fri 16:39]
   CLOCK: [2009-10-09 Fri 16:25]--[2009-10-09 Fri 16:39] =>  0:14
   :END:
: git filter-branch --env-filter '
: export  GIT_AUTHOR_EMAIL="Reimar.Finken@gmx.de"
: export  GIT_COMMITTER_EMAIL="Reimar.Finken@gmx.de"
: '
** DONE Decide whether to write to a buffer or to a temporary file
   :LOGBOOK:
   - State "DONE"       from "STARTED"    [2009-10-13 Tue 15:20]
   CLOCK: [2009-10-07 Wed 14:41]--[2009-10-07 Wed 15:00] =>  0:19
   :END:
   I don't know whether one can view e.g. images (.png) directly
   in an emacs buffer. To my knowledge only temporary files are
   treated according to auto-mode-alist. In branch savefile I
   will use temporary files, which are then opened with org-open-file.
   later and first go with the temorary buffer route.
** TODO decide how to display commits
   :LOGBOOK:
   - Note taken on [2009-10-13 Tue 15:19] \\
     in a separate branch
   :END:
** TODO Decide whether we need special export treatment
   See =export= argument in =org-add-link-type=
